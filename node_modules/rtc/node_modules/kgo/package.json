{
  "name": "kgo",
  "version": "2.0.0",
  "description": "Flow control the super easy way",
  "main": "kgo.js",
  "scripts": {
    "test": "node test"
  },
  "author": {
    "name": "Kory Nunn",
    "email": "knunn187@gmail.com"
  },
  "license": "MIT",
  "directories": {
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/korynunn/kgo.git"
  },
  "bugs": {
    "url": "https://github.com/korynunn/kgo/issues"
  },
  "homepage": "https://github.com/korynunn/kgo",
  "devDependencies": {
    "grape": "^1.0.1"
  },
  "testling": {
    "files": "./test/index.js",
    "browsers": [
      "ie/6..latest",
      "chrome/22..latest",
      "firefox/16..latest",
      "safari/latest",
      "opera/11.0..latest",
      "iphone/6",
      "ipad/6",
      "android-browser/latest"
    ]
  },
  "readme": "kgo\n===\n\nStupidly easy flow control.\n\n## Why\n\nflow contol should be seamless, you should be able to say what you want done, and say kgo.\n\n## Usage\n\n    kgo(result name, [dependencies], asynchronous function);\n\nwhere result name is an arbitrary string that can be concidered a name for the output of the function,\n\ndependencies is an array of strings that map to the output of another function,\n\nand asynchronous function is a function that, when complete, calls a callback with its results.\n\nkgo returns its-self, so it can be chained:\n\n    kgo\n    (name, deps, fn)\n    (name, deps, fn)\n    (name, deps, fn);\n\n## Example\n\nrequire kgo:\n\n    var kgo = require('./kgo');\n\nuse kgo:\n\n    kgo\n    ('things', function(done){\n\n        //Something async\n        setTimeout(function(){\n            done(null, 1);\n        }, 100);\n\n    })\n    ('stuff', function(done){\n\n        //Something async\n        setTimeout(function(){\n            done(null, 2);\n        }, 100);\n\n    })\n    ('whatsits', ['things', 'stuff'], function(things, stuff, done){\n\n        //Something async\n        setTimeout(function(){\n            done(null, things + stuff);\n        }, 100);\n\n    })\n    ('dooby', ['things'], function(things, done){\n\n        //Something async\n        setTimeout(function(){\n            done(null, things/2);\n        }, 100);\n\n    })\n    (['whatsits', 'dooby'], function(whatsits, dooby, done){\n\n        //Done\n        console.log(whatsits, dooby);\n\n    })\n    .on('complete', function(){\n        // All dones have been called OR an error occured\n    });\n    .on('error', function(error, stepNames){\n        // handle the error for the given step.\n    });\n\nThe above will log 3, 0.5;\n\n## Async Mapping\n\nRemoved as of version 2. Use (foreign)[https://www.npmjs.com/package/foreign] instead.\n\n## Ignoring dependency results\n\nYou will often not need the result of a dependency, and it's annoying to have unused parameters in your functions.\nYou can specify that you have a dependancy, whos result you don't want, by prefixing the dependancy name with an exclamation mark:\n\n    kgo\n\n    ('a', function(done){\n        done(null, 'foo');\n    })\n\n    ('b', ['!a'], function(done){\n        done(null, 'bar');\n    })\n\n    (['b'],  function(b){\n        // here b will be \"bar\"\n    });\n\n## Defaults\n\nYou can define default data for use in later tasks by passing an object into kgo, where the keys in the objects will map to dependency names:\n\n    kgo\n\n    ({\n        foo: 1    \n    })\n\n    ('bar', function(done){\n        done(null, 2);\n    })\n\n    ('baz', ['foo', 'bar'], function(foo, bar, done){\n\n    });\n\nThis is especially useful when you want to use named functions that need additional parameters to run:\n\n    var fs = require('fs');\n\n    kgo\n    ({\n        'sourcePath': '/foo/bar'\n    })\n    ('files', ['sourcePath'], fs.readdir);\n\n### Note: You may only define defaults once in a kgo block. Extra calls will result in an error.\n\n## Multiple results\n\nYou can return more than one result in a single task by giving your task multiple names, and returning more results in the callback\n\n    kgo\n\n    ('foo', 'bar', function(done){\n        done(null, 2, 4);\n    })\n\n    ('baz', ['foo', 'bar'], function(foo, bar, done){\n        // foo === 2\n        // bar === 4\n    });\n\n## Errors\n\nYeah them annoying things.\n\nkgo has EventEmitter methods on it, so you can bind to 'error'\n\nThe handler gets passed the error, and the name of the step that returned the error.\n\n    kgo\n    (task)\n    (another task)\n    .on('error', function(error, stepName){\n\n    });\n\n## Complete\n\nthe `complete` event will be emitted when either an error has been returned, or all tasks done methods have been called.\n\n    kgo\n    (task)\n    (another task)\n    .on('complete', function(){\n\n    });",
  "readmeFilename": "README.md",
  "_id": "kgo@2.0.0",
  "dist": {
    "shasum": "2b91f834fa574e4c8efa76d9f43c49f6de7cf557"
  },
  "_from": "kgo@^2.0.0",
  "_resolved": "https://registry.npmjs.org/kgo/-/kgo-2.0.0.tgz"
}
