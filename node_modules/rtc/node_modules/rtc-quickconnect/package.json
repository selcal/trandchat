{
  "name": "rtc-quickconnect",
  "version": "4.2.1",
  "description": "Create a WebRTC connection in record time",
  "main": "index.js",
  "scripts": {
    "test": "browserify test/all.js | broth ./.travis/start-$BROWSER.sh | tap-spec",
    "gendocs": "gendocs > README.md"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rtc-io/rtc-quickconnect.git"
  },
  "keywords": [
    "rtc.io",
    "webrtc"
  ],
  "author": {
    "name": "Damon Oehlman",
    "email": "damon.oehlman@nicta.com.au"
  },
  "license": "Apache 2.0",
  "bugs": {
    "url": "https://github.com/rtc-io/rtc-quickconnect/issues"
  },
  "dependencies": {
    "cog": "^1",
    "mbus": "^2.0.0",
    "rtc-attach": "^2.0.1",
    "rtc-capture": "^1.0.2",
    "rtc-core": "^4.0.0",
    "rtc-pluggable-signaller": "^1.1.0",
    "rtc-signaller": "^5.1.0",
    "rtc-tools": "^4.2.0"
  },
  "devDependencies": {
    "async": "^0.9",
    "attachmediastream": "^1.0.1",
    "broth": "^1.1.0",
    "browserify": "^9.0.3",
    "crel": "^2.1.5",
    "fdom": "^1.2.0",
    "freeice": "^2.1.1",
    "getusermedia": "^1.1.0",
    "grunt": "^0.4.5",
    "grunt-browserify": "^3.4.0",
    "grunt-contrib-uglify": "^0.8.0",
    "grunt-contrib-watch": "^0.6.1",
    "rtc-bufferedchannel": "^0.5.0",
    "rtc-captureconfig": "^2.1.0",
    "rtc-filter-grayscale": "~0.1.0",
    "rtc-media": "^1",
    "rtc-plugin-temasys": "^1.1.1",
    "rtc-quickconnect-test": "^1.1.0",
    "rtc-switchboard": "^2.0.0",
    "rtc-videoproc": "^0.11.0",
    "tap-spec": "^2.2.2",
    "uuid": "^2.0.1",
    "whisk": "^1.0.0"
  },
  "contributors": [
    {
      "name": "Damon Oehlman",
      "email": "damon.oehlman@nicta.com.au",
      "url": "https://github.com/DamonOehlman"
    },
    {
      "name": "Silvia Pfeiffer",
      "email": "silvia.pfeiffer@nicta.com.au",
      "url": "https://github.com/silviapfeiffer"
    }
  ],
  "readme": "# rtc-quickconnect\n\nThis is a high level helper module designed to help you get up\nan running with WebRTC really, really quickly.  By using this module you\nare trading off some flexibility, so if you need a more flexible\nconfiguration you should drill down into lower level components of the\n[rtc.io](http://www.rtc.io) suite.  In particular you should check out\n[rtc](https://github.com/rtc-io/rtc).\n\n\n[![NPM](https://nodei.co/npm/rtc-quickconnect.png)](https://nodei.co/npm/rtc-quickconnect/)\n\n[![Build Status](https://img.shields.io/travis/rtc-io/rtc-quickconnect.svg?branch=master)](https://travis-ci.org/rtc-io/rtc-quickconnect) [![unstable](https://img.shields.io/badge/stability-unstable-yellowgreen.svg)](https://github.com/dominictarr/stability#unstable) \n[![rtc.io google group](http://img.shields.io/badge/discuss-rtc.io-blue.svg)](https://groups.google.com/forum/#!forum/rtc-io)\n\n\n\n## Example Usage\n\nIn the simplest case you simply call quickconnect with a single string\nargument which tells quickconnect which server to use for signaling:\n\n```js\nvar quickconnect = require('rtc-quickconnect');\n\nquickconnect('https://switchboard.rtc.io/', { room: 'qc-simple-demo' })\n  .on('call:started', function(id, pc, data) {\n    console.log('we have a new connection to: ' + id);\n  });\n\n```\n\n## Events\n\nThe following events are emitted from the signalling object created by calling `quickconnect()`. Additionally, any of the underlying [signaller events](https://github.com/rtc-io/rtc-signaller#signaller-events) can also be used.\n\n### Peer Level Events\n\nThe peer level events provided in quickconnect provide you the ability to tap into the various stages of the lifecycle for connecting with a peer, before the connection actually migrates to the status of a connected \"call\".\n\n- `peer:connect => function(id, peerconnection, data)`\n\n  The `peer:connect` event is emitted when we first create a connection to a discovered peer.  The `peerconnection` argument is a standard `RTCPeerConnection` instance.\n\n- `peer:couple => funtion(id, peerconnection, data, monitor)`\n\n  The `peer:couple` event is emitted when once quickconnect has [coupled](https://github.com/rtc-io/rtc-tools#rtc-toolscouple) to it's remote counterpart.\n\n### Call Level Events\n\nA \"call\" in quickconnect is equivalent to an established `RTCPeerConnection` between this quickconnect instance a remote peer.\n\n- `call:started => function(id, peerconnection, data)`\n\n  Triggered once a peer connection has been established been established between this quickconnect instance and another.\n\n- `call:ended => function(id)`\n\n  Triggered when a peer connection has been closed.  This may be due to the peer connection itself indicating that it has been closed, or we may have lost connection with the remote signaller and the connection has timed out.\n\n### Data Channel Level Events\n\n- `channel:opened => function(id, datachannel, data)`\n\n  The `channel:opened` event is triggered whenever an `RTCDataChannel` has been opened (it's ready to send data) to a remote peer.\n\n- `channel:opened:%label% => function(id, datachannel, data)`\n\n  This is equivalent of the `channel:opened` event, but only triggered for a channel with label `%label%`.  For example:\n\n  ```js\n  quickconnect('https://switchboard.rtc.io/', { room: 'test' })\n    .createDataChannel('foo')\n    .createDataChannel('bar')\n    .on('channel:opened:foo', function(id, dc) {\n      console.log('channel foo opened for peer: ' + id);\n    });\n  ```\n\n  In the case above the console message would only be displayed for the `foo` channel once open, and when the `bar` channel is opened no handler would be invoked.\n\n- `channel:closed => function(id, datachannel, label)`\n\n  Emitted when the channel has been closed, works when a connection has been closed or the channel itself has been closed.\n\n- `channel:closed:%label% => function(id, datachannel, label)`\n\n  The label specific equivalent of `channel:closed`.\n\n### Stream Level Events\n\n- `stream:added => function(id, stream, data)`\n\n  The `stream:added` event is triggered when an `RTCPeerConnection` has successfully been established to another peer that contains remote streams.  Additionally, if you are using quickconnect in it's \"reactive\" mode then you will also receive `stream:added` events as streams are dynamically added to the connection by the remote peer.\n\n- `stream:removed => function(id)`\n\n  As per the `stream:added` event but triggered when a stream has been removed.\n\n\n## Example Usage (using data channels)\n\nWhen working with WebRTC data channels, you can call the `createDataChannel` function helper that is attached to the object returned from the `quickconnect` call.  The `createDataChannel` function signature matches the signature of the `RTCPeerConnection` `createDataChannel` function.\n\nAt the minimum it requires a label for the channel, but you can also pass through a dictionary of options that can be used to fine tune the data channel behaviour.  For more information on these options, I'd recommend having a quick look at the WebRTC spec:\n\n<http://dev.w3.org/2011/webrtc/editor/webrtc.html#dictionary-rtcdatachannelinit-members>\n\nIf in doubt, I'd recommend not passing through options.\n\n```js\nvar freeice = require('freeice');\nvar quickconnect = require('rtc-quickconnect');\nvar opts = {\n  room: 'qcexample-dctest',\n  // debug: true,\n  iceServers: freeice()\n};\n\nquickconnect('https://switchboard.rtc.io/', opts)\n  // tell quickconnect we want a datachannel called test\n  .createDataChannel('test')\n  // when the test channel is open, let us know\n  .on('channel:opened:test', function(id, dc) {\n    dc.onmessage = function(evt) {\n      console.log('peer ' + id + ' says: ' + evt.data);\n    };\n\n    console.log('test dc open for peer: ' + id);\n    dc.send('hi');\n  });\n\n```\n\n## Example Usage (using captured media)\n\nAnother example is displayed below, and this example demonstrates how to use `rtc-quickconnect` to create a simple video conferencing application:\n\n```js\nvar quickconnect = require('rtc-quickconnect');\nvar crel = require('crel');\nvar getUserMedia = require('getusermedia');\nvar attachmediastream = require('attachmediastream');\nvar qsa = require('fdom/qsa');\n\n// create containers for our local and remote video\nvar local = crel('div', { class: 'local' });\nvar remote = crel('div', { class: 'remote' });\nvar peerMedia = {};\n\n// once media is captured, connect\ngetUserMedia({ audio: true, video: true }, function(err, localStream) {\n  if (err) {\n    return console.error('could not capture media: ', err);\n  }\n\n  // render the local media\n  local.appendChild(attachmediastream(localStream));\n\n  // initiate connection\n  quickconnect('https://switchboard.rtc.io/', { room: 'conftest' })\n    // broadcast our captured media to other participants in the room\n    .addStream(localStream)\n    // when a peer is connected (and active) pass it to us for use\n    .on('call:started', function(id, pc, data) {\n      var videos = pc.getRemoteStreams().map(attachmediastream);\n      videos.forEach(function(video) {\n        video.dataset.peer = id;\n        remote.appendChild(video);\n      });\n    })\n    // when a peer leaves, remove teh media\n    .on('call:ended', function(id) {\n      qsa('*[data-peer=\"' + id + '\"]', remote).forEach(function(el) {\n        el.parentNode.removeChild(el);\n      });\n    });\n});\n\n/* extra code to handle dynamic html and css creation */\n\n// add some basic styling\ndocument.head.appendChild(crel('style', [\n  '.local { position: absolute;  right: 10px; }',\n  '.local video { max-width: 200px; }'\n].join('\\n')));\n\n// add the local and remote elements\ndocument.body.appendChild(local);\ndocument.body.appendChild(remote);\n\n```\n\n\n## Regarding Signalling and a Signalling Server\n\nSignaling is an important part of setting up a WebRTC connection and for\nour examples we use our own test instance of the\n[rtc-switchboard](https://github.com/rtc-io/rtc-switchboard). For your\ntesting and development you are more than welcome to use this also, but\njust be aware that we use this for our testing so it may go up and down\na little.  If you need something more stable, why not consider deploying\nan instance of the switchboard yourself - it's pretty easy :)\n\n## Reference\n\n```\nquickconnect(signalhost, opts?) => rtc-sigaller instance (+ helpers)\n```\n\n### Valid Quick Connect Options\n\nThe options provided to the `rtc-quickconnect` module function influence the\nbehaviour of some of the underlying components used from the rtc.io suite.\n\nListed below are some of the commonly used options:\n\n- `ns` (default: '')\n\n  An optional namespace for your signalling room.  While quickconnect\n  will generate a unique hash for the room, this can be made to be more\n  unique by providing a namespace.  Using a namespace means two demos\n  that have generated the same hash but use a different namespace will be\n  in different rooms.\n\n- `room` (default: null) _added 0.6_\n\n  Rather than use the internal hash generation\n  (plus optional namespace) for room name generation, simply use this room\n  name instead.  __NOTE:__ Use of the `room` option takes precendence over\n  `ns`.\n\n- `debug` (default: false)\n\nWrite rtc.io suite debug output to the browser console.\n\n- `expectedLocalStreams` (default: not specified) _added 3.0_\n\n  By providing a positive integer value for this option will mean that\n  the created quickconnect instance will wait until the specified number of\n  streams have been added to the quickconnect \"template\" before announcing\n  to the signaling server.\n\n- `manualJoin` (default: `false`)\n\n  Set this value to `true` if you would prefer to call the `join` function\n  to connecting to the signalling server, rather than having that happen\n  automatically as soon as quickconnect is ready to.\n\n#### Options for Peer Connection Creation\n\nOptions that are passed onto the\n[rtc.createConnection](https://github.com/rtc-io/rtc#createconnectionopts-constraints)\nfunction:\n\n- `iceServers`\n\nThis provides a list of ice servers that can be used to help negotiate a\nconnection between peers.\n\n#### Options for P2P negotiation\n\nUnder the hood, quickconnect uses the\n[rtc/couple](https://github.com/rtc-io/rtc#rtccouple) logic, and the options\npassed to quickconnect are also passed onto this function.\n\n### Quickconnect Broadcast and Data Channel Helper Functions\n\nThe following are functions that are patched into the `rtc-signaller`\ninstance that make working with and creating functional WebRTC applications\na lot simpler.\n\n#### addStream\n\n```\naddStream(stream:MediaStream) => qc\n```\n\nAdd the stream to active calls and also save the stream so that it\ncan be added to future calls.\n\n#### endCalls()\n\nThe `endCalls` function terminates all the active calls that have been\ncreated in this quickconnect instance.  Calling `endCalls` does not\nkill the connection with the signalling server.\n\n#### close()\n\nThe `close` function provides a convenient way of closing all associated\npeer connections.  This function simply uses the `endCalls` function and\nthe underlying `leave` function of the signaller to do a \"full cleanup\"\nof all connections.\n\n#### createDataChannel(label, config)\n\nRequest that a data channel with the specified `label` is created on\nthe peer connection.  When the data channel is open and available, an\nevent will be triggered using the label of the data channel.\n\nFor example, if a new data channel was requested using the following\ncall:\n\n```js\nvar qc = quickconnect('https://switchboard.rtc.io/').createDataChannel('test');\n```\n\nThen when the data channel is ready for use, a `test:open` event would\nbe emitted by `qc`.\n\n#### join()\n\nThe `join` function is used when `manualJoin` is set to true when creating\na quickconnect instance.  Call the `join` function once you are ready to\njoin the signalling server and initiate connections with other people.\n\n#### `get(name)`\n\nThe `get` function returns the property value for the specified property name.\n\n#### `getLocalStreams()`\n\nReturn a copy of the local streams that have currently been configured\n\n#### reactive()\n\nFlag that this session will be a reactive connection.\n\n#### removeStream\n\n```\nremoveStream(stream:MediaStream)\n```\n\nRemove the specified stream from both the local streams that are to\nbe connected to new peers, and also from any active calls.\n\n#### requestChannel\n\n```\nrequestChannel(targetId, label, callback)\n```\n\nThis is a function that can be used to respond to remote peers supplying\na data channel as part of their configuration.  As per the `receiveStream`\nfunction this function will either fire the callback immediately if the\nchannel is already available, or once the channel has been discovered on\nthe call.\n\n#### requestStream\n\n```\nrequestStream(targetId, idx, callback)\n```\n\nUsed to request a remote stream from a quickconnect instance. If the\nstream is already available in the calls remote streams, then the callback\nwill be triggered immediately, otherwise this function will monitor\n`stream:added` events and wait for a match.\n\nIn the case that an unknown target is requested, then an exception will\nbe thrown.\n\n#### profile(data)\n\nUpdate the profile data with the attached information, so when\nthe signaller announces it includes this data in addition to any\nroom and id information.\n\n#### waitForCall\n\n```\nwaitForCall(targetId, callback)\n```\n\nWait for a call from the specified targetId.  If the call is already\nactive the callback will be fired immediately, otherwise we will wait\nfor a `call:started` event that matches the requested `targetId`\n\n## License(s)\n\n### Apache 2.0\n\nCopyright 2015 National ICT Australia Limited (NICTA)\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n",
  "readmeFilename": "README.md",
  "_id": "rtc-quickconnect@4.2.1",
  "dist": {
    "shasum": "949ef226d2e2883dc8ef1af69e9544f6373be5f6"
  },
  "_from": "rtc-quickconnect@^4.1.0",
  "_resolved": "https://registry.npmjs.org/rtc-quickconnect/-/rtc-quickconnect-4.2.1.tgz"
}
